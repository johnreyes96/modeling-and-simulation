# -*- coding: utf-8 -*-
"""SegmentacionDataSetMall.ipynb

Automatically generated by Colaboratory.

#Segmentación y agrupamiento de clientes usando K-means en Python

- ¿Qué es la segmentación de clientes?

La segmentación de clientes es la práctica de dividir una base de clientes en grupos que tienen características homogéneas como edad, género, intereses y hábitos de consumo, etc.

- Beneficios de la segmentación de clientes

Las empresas están interesadas en la segmentación de clientes porque cada cliente es diferente. Sus esfuerzos de marketing serían mejores si se dirigieran a grupos específicos y más pequeños con mensajes que esos consumidores encontrarían relevantes y, finalmente, los alentarían a comprar algo. Las empresas también están interesadas en conocer las características de estos grupos de clientes y sus preferencias de compra. Lo cual de nuevo ayudaría en la toma de decisiones de marketing.

La segmentación de clientes también puede ayudar a mejorar el servicio al cliente y asistir en la lealtad y retención de clientes. El material de marketing personalizado enviado al cliente es más apreciado por los clientes que simplemente enviarles anuncios de marketing generales. Hace que el cliente sea más valorado cuando la empresa tiene en cuenta el historial de compras de los clientes.

- Planteamiento del problema

Comprender los clientes objetivo para que el equipo de mercado planifique una estrategia

- Contexto

El gerente comercial quiere que el científico de datos identifique el grupo de compras más importante en función de los ingresos, la edad y el puntaje de compras en el centro comercial. Quiere el número ideal de grupos con una etiqueta para cada uno.

El objetivo es la segmentación del mercado, es decir, dividir el mercado objetivo o los clientes del centro comercial en grupos accesibles. Cree subconjuntos de clientes basados ​​en criterios demográficos y de comportamiento para comprender mejor el objetivo de las actividades de marketing.

## Cargando datos y librerias
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import warnings
warnings.filterwarnings('ignore')

df = pd.read_csv('../../data/Mall_Customers.csv')

df.head()

"""## Análisis univariado

Antes de comenzar a agrupar, se realiza un análisis exploratorio de datos mediante las estadísticas descriptivas de los datos.
"""

df.describe()

"""Los diagramas de densidad"""

sns.distplot(df['Annual Income (k$)']);

df.columns

"""Distribución de todas las variables"""

columns = ['Age', 'Annual Income (k$)','Spending Score (1-100)']
for i in columns:
    plt.figure()
    sns.distplot(df[i])

sns.kdeplot(df['Annual Income (k$)'],shade=True,hue=df['Gender']);

columns = ['Age', 'Annual Income (k$)','Spending Score (1-100)']
for i in columns:
    plt.figure()
    sns.kdeplot(df[i],shade=True,hue=df['Gender'])

columns = ['Age', 'Annual Income (k$)','Spending Score (1-100)']
for i in columns:
    plt.figure()
    sns.boxplot(data=df,x='Gender',y=df[i])

df['Gender'].value_counts(normalize=True)

"""## Análisis bivariado

El análisis bivariado es donde comparamos dos variables y con el propósito de determinar la relación empírica entre ellas. El gráfico de dispersión se utiliza para las comparaciones. Al menos cinco grupos o grupos de clientes son visibles en el siguiente diagrama de dispersión.
"""

sns.scatterplot(data=df, x='Annual Income (k$)',y='Spending Score (1-100)' )

"""Se generan gráficos de pares que muestran la relación de todas las columnas y también muestran el tono según el género.


"""

sns.pairplot(df,hue='Gender')

"""Del gráfico anterior parece que hay un gran porcentaje de clientas en el conjunto de datos. Se explorará más a fondo. echemos un vistazo a la edad media, el ingreso anual y el puntaje de gasto según el género. El ingreso anual para los hombres es más alto y el puntaje de gasto es un poco más alto para las clientas."""

df.groupby(['Gender'])['Age', 'Annual Income (k$)',
       'Spending Score (1-100)'].mean()

"""El valor R-cuadrado, denotado por R 2, es el cuadrado de la correlación. Mide la proporción de variación en la variable dependiente que se puede atribuir a la variable independiente. El valor de R-cuadrado R 2 está siempre entre 0 y 1 inclusive. Vamos a generar la correlación para todas las columnas. puntuación de gastos y la edad tiene una correlación negativa. Lo que significa que con el aumento de la edad, el puntaje de gasto disminuye. Y la puntuación anual de ingresos y gastos tiene una correlación ligeramente positiva. La correlación también se puede visualizar a través de mapas de calor."""

df.corr()

sns.heatmap(df.corr(),annot=True,cmap='coolwarm')

"""## Clustering

Después de un análisis exploratorio, comencemos el agrupamiento real. Usamos el algoritmo K-medias aquí para la agrupación. Primero realizamos el agrupamiento univariado y el bivariado.

El agrupamiento de K-means es un tipo de aprendizaje no supervisado, que se usa cuando tiene datos sin etiquetar (es decir, datos sin categorías o grupos definidos). El objetivo de este algoritmo es encontrar grupos en los datos, con el número de grupos representado por la variable K. Comencemos eligiendo un valor aleatorio o cercano a lo que creemos que podría ser el número de grupos.
"""

clustering1 = KMeans(n_clusters=6)

"""Aquí el agrupamiento se basa en el ingreso anual, ya que estamos haciendo un agrupamiento univariante."""

clustering1.fit(df[['Annual Income (k$)']])

"""Las etiquetas de los grupos agrégarlas como una nueva columna en el conjunto de datos

"""

clustering1.labels_

df['Income Cluster'] = clustering1.labels_
df.head()

df['Income Cluster'].value_counts()

"""La inercia mide qué tan bien K-Means agrupa un conjunto de datos. Se calcula midiendo la distancia entre cada punto de datos y su centroide, elevando al cuadrado esta distancia y sumando estos cuadrados en un grupo. Un buen modelo es uno con baja inercia Y un bajo número de grupos ( K ). Se podría encontrar un valor más bajo para encontrar N valor óptimo de conglomerados

"""

clustering1.inertia_

"""El método del codo ejecuta la agrupación de k-medias en el conjunto de datos para un rango de valores de k (por ejemplo, de 1 a 10) y luego, para cada valor de k, calcula una puntuación promedio para todas las agrupaciones. Usamos el método del codo aquí para encontrar una inercia más baja y un número apropiado de grupos."""

intertia_scores=[]
for i in range(1,11):
    kmeans=KMeans(n_clusters=i)
    kmeans.fit(df[['Annual Income (k$)']])
    intertia_scores.append(kmeans.inertia_)

intertia_scores

"""Para determinar el número óptimo de grupos, tenemos que seleccionar el valor de k en el "codo", es decir, el punto después del cual la distorsión/inercia comienza a disminuir de forma lineal. Al mirar el gráfico a continuación, podemos ver que el codo comienza entre 2 y 4 en algún lugar donde 3. Elegimos 3 como número de grupos y volvemos a entrenar nuestro modelo.

"""

plt.plot(range(1,11),intertia_scores)
plt.xlabel('Values of K')
plt.ylabel('Inertia')

df.columns

"""Ahora podemos ver la media de cada uno de los tres grupos agrupados por grupo"""

df.groupby('Income Cluster')['Age', 'Annual Income (k$)',
       'Spending Score (1-100)'].mean()

"""El agrupamiento bivariado es donde agrupamos nuestros puntos de datos, los clientes en este caso según dos columnas o características. Repitamos el mismo proceso, solo que esta vez tomaremos ambas columnas Ingreso anual y puntaje de gastos para crear grupos, tomaremos un número aleatorio para el grupo como 3 y luego trabajaremos más tarde para reducir la inercia y encontrar el número apropiado de grupos.

"""

clustering2 = KMeans(n_clusters=5)
clustering2.fit(df[['Annual Income (k$)','Spending Score (1-100)']])
df['Spending and Income Cluster'] =clustering2.labels_
df.head()

intertia_scores2=[]
for i in range(1,11):
    kmeans2=KMeans(n_clusters=i)
    kmeans2.fit(df[['Annual Income (k$)','Spending Score (1-100)']])
    intertia_scores2.append(kmeans2.inertia_)
plt.plot(range(1,11),intertia_scores2)
plt.xlabel('Values of K')
plt.ylabel('Inertia')

"""Averigüemos ahora el centro de cada grupo, nos dara una idea del punto de datos más cercano a cualquiera de estos centros, donde los datos se agregarán a ese grupo en particular.

"""

centers =pd.DataFrame(clustering2.cluster_centers_)
centers.columns = ['x','y']

plt.figure(figsize=(10,8))
plt.scatter(x=centers['x'],y=centers['y'],s=100,c='black',marker='*')
sns.scatterplot(data=df, x ='Annual Income (k$)',y='Spending Score (1-100)',hue='Spending and Income Cluster',palette='tab10')

pd.crosstab(df['Spending and Income Cluster'],df['Gender'],normalize='index')

df.groupby('Spending and Income Cluster')['Age', 'Annual Income (k$)',
       'Spending Score (1-100)'].mean()

"""Análisis/recomendaciones

Del análisis de datos realizado aquí obtuvimos los siguientes hallazgos que podemos transmitir a la empresa.

- El grupo 1 muestra características de altos ingresos y altos gastos. Y tiene un 54 % de clientes mujeres; sería más beneficioso para la empresa dirigirse a este grupo con campañas de marketing personalizadas.

- El grupo 2 también es un hallazgo interesante. Los clientes, aunque tienen bajos ingresos, siguen gastando mucho. tal vez vienen por algunos artículos de venta. Se pueden realizar más análisis para tener una idea de sus preferencias de compra y, por lo tanto, anuncios de marketing personalizados.

"""