# -*- coding: utf-8 -*-
"""MarkovChains.ipynb

Automatically generated by Colaboratory.

# 1째 algorithm
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

states = ["Sleep", "Play", "Mix"]  # The statespace
transitionName = [["SS", "SP", "SM"], ["PS", "PP", "PM"], ["MS", "MP", "MM"]]  # Possible sequences of events
transitionMatrix = [[0.5, 0.3, 0.2], [0.7, 0.2, 0.1], [0.3, 0.6, 0.1]]  # Probabilities matrix (transition matrix)

if sum(transitionMatrix[0]) + sum(transitionMatrix[1]) + sum(transitionMatrix[1]) != 3:
    print("Somewhere, something went wrong. Transition matrix, perhaps?")
else:
    print("All is gonna be okay, you should move on!! ;)")


# A function that implements the Markov model to forecast the state/mood.
def activity_forecast(days):
    # Choose the starting state
    activity_today = "Sleep"
    print("Start state: " + activity_today)
    # Shall store the sequence of states taken. So, this only has the starting state for now.
    activity_list = [activity_today]
    i = 0
    # To calculate the probability of the activity_list
    prob = 1
    while i != days:
        if activity_today == "Sleep":
            change = np.random.choice(transitionName[0], replace=True, p=transitionMatrix[0])
            if change == "SS":
                prob = prob * 0.2
                activity_list.append("Sleep")
                pass
            elif change == "SM":
                prob = prob * 0.6
                activity_today = "Mix"
                activity_list.append("Mix")
            else:
                prob = prob * 0.2
                activity_today = "Play"
                activity_list.append("Play")
        elif activity_today == "Mix":
            change = np.random.choice(transitionName[1], replace=True, p=transitionMatrix[1])
            if change == "MM":
                prob = prob * 0.5
                activity_list.append("Mix")
                pass
            elif change == "MS":
                prob = prob * 0.2
                activity_today = "Sleep"
                activity_list.append("Sleep")
            else:
                prob = prob * 0.3
                activity_today = "Play"
                activity_list.append("Play")
        elif activity_today == "Play":
            change = np.random.choice(transitionName[2], replace=True, p=transitionMatrix[2])
            if change == "PP":
                prob = prob * 0.1
                activity_list.append("Play")
                pass
            elif change == "PS":
                prob = prob * 0.2
                activity_today = "Play"
                activity_list.append("Play")
            else:
                prob = prob * 0.7
                activity_today = "Mix"
                activity_list.append("Mix")
        i += 1
    print("Possible states: " + str(activity_list))
    print("End state after " + str(days) + " days: " + activity_today)
    print("Probability of the possible sequence of states: " + str(prob))
    print("")


# Function that forecasts the possible state for the next 2 days
activity_forecast(2)
activity_forecast(6)

"""# 2째 algorithm"""

# The statespace
states = ["Sleep", "Icecream", "Run"]

# Possible sequences of events
transitionName = [["SS", "SR", "SI"], ["RS", "RR", "RI"], ["IS", "IR", "II"]]

# Probabilities matrix (transition matrix)
transitionMatrix = [[0.2, 0.6, 0.2], [0.1, 0.6, 0.3], [0.2, 0.7, 0.1]]

if sum(transitionMatrix[0]) + sum(transitionMatrix[1]) + sum(transitionMatrix[1]) != 3:
    print("Somewhere, something went wrong. Transition matrix, perhaps?")
else:
    print("All is gonna be okay, you should move on!! ;)")


def activity_forecast(days):
    # Choose the starting state
    activity_today = "Sleep"
    activity_list = [activity_today]
    i = 0
    prob = 1
    while i != days:
        if activity_today == "Sleep":
            change = np.random.choice(transitionName[0], replace=True, p=transitionMatrix[0])
            if change == "SS":
                prob = prob * 0.2
                activity_list.append("Sleep")
                pass
            elif change == "SR":
                prob = prob * 0.6
                activity_today = "Run"
                activity_list.append("Run")
            else:
                prob = prob * 0.2
                activity_today = "Icecream"
                activity_list.append("Icecream")
        elif activity_today == "Run":
            change = np.random.choice(transitionName[1], replace=True, p=transitionMatrix[1])
            if change == "RR":
                prob = prob * 0.5
                activity_list.append("Run")
                pass
            elif change == "RS":
                prob = prob * 0.2
                activity_today = "Sleep"
                activity_list.append("Sleep")
            else:
                prob = prob * 0.3
                activity_today = "Icecream"
                activity_list.append("Icecream")
        elif activity_today == "Icecream":
            change = np.random.choice(transitionName[2], replace=True, p=transitionMatrix[2])
            if change == "II":
                prob = prob * 0.1
                activity_list.append("Icecream")
                pass
            elif change == "IS":
                prob = prob * 0.2
                activity_today = "Sleep"
                activity_list.append("Sleep")
            else:
                prob = prob * 0.7
                activity_today = "Run"
                activity_list.append("Run")
        i += 1
    return activity_list


# To save every activityList
list_activity = []
count = 0

# `Range` starts from the first count up until but excluding the last count
for iterations in range(1, 10000):
    list_activity.append(activity_forecast(2))

# Check out all the `activityList` we collected
# print(list_activity)

# Iterate through the list to get a count of all activities ending in state:'Run'
for smaller_list in list_activity:
    if smaller_list[2] == "Run":
        count += 1

# Calculate the probability of starting from state:'Sleep' and ending at state:'Run'
percentage = (count / 10000) * 100
print("The probability of starting at state:'Sleep' and ending at state:'Run'= " + str(percentage) + "%")

"""# 3째 algorithm"""

# matplotlib parameters
plt.rcParams["figure.figsize"] = (12, 8)
plt.rcParams.update({'font.size': 14})

mc_example = {'NYC': [.25, 0, .75, 1],
              'Paris': [.25, .25, 0, 0],
              'Cairo': [.25, .25, .25, 0],
              'Seoul': [.25, .5, 0, 0]}

mc = pd.DataFrame(data=mc_example, index=['NYC', 'Paris', 'Cairo', 'Seoul'])

travel_sim = []
travel_sim.append(mc.iloc[0].index[0])
city = np.random.choice(mc.iloc[0].index, p=mc.iloc[0])
travel_sim.append(city)

while len(travel_sim) < 25:
    city = np.random.choice(mc.iloc[mc.index.get_loc(city)].index, p=mc.iloc[mc.index.get_loc(city)])
    travel_sim.append(city)

print(travel_sim)

print(mc)

print(mc.to_numpy())


def matrix_power(matrix, power):
    if power == 0:
        return np.identity(len(matrix))
    elif power == 1:
        return matrix
    else:
        return np.dot(matrix, matrix_power(matrix, power - 1))


print(matrix_power(mc.to_numpy(), 2))

print(np.dot(np.dot(mc.to_numpy(), mc.to_numpy()), mc.to_numpy()))

print(np.dot(mc.to_numpy(), mc.to_numpy()))

print(matrix_power(mc.to_numpy(), 3).sum(axis=1))

for i in range(1, 10, 1):
    print(f'n Step Transition Matrix at the nth power {i}\n', matrix_power(mc.to_numpy(), i), '\n')

"""# 4째 algorithm - Monte Carlo"""

plt.rcParams['figure.figsize'] = [10, 6]
np.random.seed(42)

state_space = ("sunny", "cloudy", "rainy")

transition_matrix = np.array(((0.6, 0.3, 0.1),
                              (0.3, 0.4, 0.3),
                              (0.2, 0.3, 0.5)))

n_steps = 20000
states = [0]
for i in range(n_steps):
    states.append(np.random.choice((0, 1, 2), p=transition_matrix[states[-1]]))  # add , 3, 4, 5, 6, 7
states = np.array(states)


def despine(ax, spines=('top', 'left', 'right')):
    for spine in spines:
        ax.spines[spine].set_visible(False)


fig, ax = plt.subplots()
width = 1000
offsets = range(1, n_steps, 5)
for i, label in enumerate(state_space):
    ax.plot(offsets, [np.sum(states[:offset] == i) / offset
                      for offset in offsets], label=label)
ax.set_xlabel("number of steps")
ax.set_ylabel("likelihood")
ax.legend(frameon=False)
despine(ax, ('top', 'right'))
plt.show()


def log_prob(x):
    return -0.5 * np.sum(x ** 2)


def proposal(x, stepsize):
    return np.random.uniform(low=x - 0.5 * stepsize,
                             high=x + 0.5 * stepsize,
                             size=x.shape)


def p_acc_MH(x_new, x_old, log_prob):
    return min(1, np.exp(log_prob(x_new) - log_prob(x_old)))


def sample_MH(x_old, log_prob, stepsize):
    x_new = proposal(x_old, stepsize)
    # here we determine whether we accept the new state or not:
    # we draw a random number uniformly from [0,1] and compare
    # it with the acceptance probability
    accept = np.random.random() < p_acc_MH(x_new, x_old, log_prob)
    if accept:
        return accept, x_new
    else:
        return accept, x_old


def build_MH_chain(init, stepsize, n_total, log_prob):
    n_accepted = 0
    chain = [init]

    for _ in range(n_total):
        accept, state = sample_MH(chain[-1], log_prob, stepsize)
        chain.append(state)
        n_accepted += accept

    acceptance_rate = n_accepted / float(n_total)

    return chain, acceptance_rate


chain, acceptance_rate = build_MH_chain(np.array([2.0]), 3.0, 10000, log_prob)
chain = [state for state, in chain]
print("Acceptance rate: {:.3f}".format(acceptance_rate))
last_states = ", ".join("{:.5f}".format(state)
                        for state in chain[-10:])
print("Last ten states of chain: " + last_states)


def plot_samples(chain, log_prob, ax, orientation='vertical', normalize=True,
                 xlims=(-5, 5), legend=True):
    from scipy.integrate import quad

    ax.hist(chain, bins=50, density=True, label="MCMC samples",
            orientation=orientation)
    # we numerically calculate the normalization constant of our PDF
    if normalize:
        Z, _ = quad(lambda x: np.exp(log_prob(x)), -np.inf, np.inf)
    else:
        Z = 1.0
    xses = np.linspace(xlims[0], xlims[1], 1000)
    yses = [np.exp(log_prob(x)) / Z for x in xses]
    if orientation == 'horizontal':
        (yses, xses) = (xses, yses)
    ax.plot(xses, yses, label="true distribution")
    if legend:
        ax.legend(frameon=False)


fig, ax = plt.subplots()
plot_samples(chain[500:], log_prob, ax)
despine(ax)
ax.set_yticks(())
plt.show()


def sample_and_display(init_state, stepsize, n_total, n_burnin, log_prob):
    chain, acceptance_rate = build_MH_chain(init_state, stepsize, n_total, log_prob)
    print("Acceptance rate: {:.3f}".format(acceptance_rate))
    fig, ax = plt.subplots()
    plot_samples([state for state, in chain[n_burnin:]], log_prob, ax)
    despine(ax)
    ax.set_yticks(())
    plt.show()


sample_and_display(np.array([2.0]), 30, 10000, 500, log_prob)

sample_and_display(np.array([2.0]), 0.1, 10000, 500, log_prob)

sample_and_display(np.array([2.0]), 0.1, 500000, 25000, log_prob)
